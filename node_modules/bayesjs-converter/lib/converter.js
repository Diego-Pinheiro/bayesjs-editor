"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = function (ast) {
    var convertNode = function (node) {
        var statesProperty = node.properties.find(function (x) { return x.name === 'states'; });
        if (statesProperty === undefined) {
            throw new Error("states not found: " + node.name);
        }
        return {
            id: node.name,
            states: statesProperty.value,
            parents: [],
            cpt: null
        };
    };
    var convertPosition = function (node) {
        var positionProperty = node.properties.find(function (x) { return x.name === 'position'; });
        if (positionProperty === undefined) {
            throw new Error("position not found: " + node.name);
        }
        return _a = {},
            _a[node.name] = {
                x: positionProperty.value[0],
                y: positionProperty.value[1]
            },
            _a;
        var _a;
    };
    var nodesAst = ast.items.filter(function (x) { return x.type === 'node'; });
    var potentialsAst = ast.items.filter(function (x) { return x.type === 'potential'; });
    var network = {
        name: 'Rede Bayesiana',
        height: 500,
        width: 800,
        selectedNodes: [],
        beliefs: {},
        propertiesPanelVisible: true
    };
    var nodes = nodesAst.map(convertNode);
    var positions = nodesAst.reduce(function (acc, x) { return (__assign({}, acc, convertPosition(x))); }, {});
    potentialsAst.forEach(function (potential) {
        var node = nodes.find(function (x) { return x.id === potential.node; });
        var data = potential.properties.find(function (x) { return x.name === 'data'; });
        if (node === undefined) {
            throw new Error("node not found: " + potential.node);
        }
        if (data === undefined) {
            throw new Error("data not found: " + potential.node);
        }
        node.parents = potential.given;
        if (node.parents.length === 0) {
            node.cpt = {};
            for (var i = 0; i < data.value.length; i++) {
                node.cpt[node.states[i]] = data.value[i];
            }
        }
        else {
            node.cpt = [];
            var buildCpt_1 = function (parents, data, when) {
                if (parents.length === 0) {
                    var then = {};
                    for (var i = 0; i < data.length; i++) {
                        then[node.states[i]] = data[i];
                    }
                    node.cpt.push({ when: when, then: then });
                    return;
                }
                var parent = parents[0], remainingParents = parents.slice(1);
                var parentNode = nodes.find(function (x) { return x.id === parent; });
                if (parentNode === undefined) {
                    throw new Error("parent not found: " + parent);
                }
                parentNode.states.forEach(function (parentState, parentIndex) {
                    var accWhen = __assign({}, when, (_a = {}, _a[parent] = parentState, _a));
                    buildCpt_1(remainingParents, data[parentIndex], accWhen);
                    var _a;
                });
            };
            buildCpt_1(node.parents, data.value, {});
        }
    });
    return {
        version: 2,
        network: network,
        nodes: nodes,
        positions: positions
    };
};
