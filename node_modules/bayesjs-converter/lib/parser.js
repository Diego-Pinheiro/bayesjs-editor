"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = function (tokens) {
    var currentIndex = 0;
    var readNextToken = function () {
        return tokens[currentIndex++];
    };
    var assertNextToken = function (type) {
        var token = readNextToken();
        if (token.type !== type) {
            throw unexpectedToken(token);
        }
    };
    var unexpectedToken = function (token) {
        return new Error("Unexpected token: " + token.type);
    };
    var parseArray = function () {
        var array = [];
        assertNextToken('openparen');
        var token = readNextToken();
        while (token.type !== 'closeparen') {
            switch (token.type) {
                case 'number':
                case 'string':
                    array.push(token.value);
                    break;
                case 'openparen':
                    currentIndex--;
                    array.push(parseArray());
                    break;
                default:
                    throw unexpectedToken(token);
            }
            token = readNextToken();
        }
        return array;
    };
    var parseProperties = function () {
        var properties = [];
        assertNextToken('openbracket');
        var token = readNextToken();
        while (token.type !== 'closebracket') {
            if (token.type !== 'identifier') {
                throw unexpectedToken(token);
            }
            var property = {
                type: 'property',
                name: token.value,
                value: ''
            };
            assertNextToken('equal');
            token = readNextToken();
            switch (token.type) {
                case 'string':
                    property.value = token.value;
                    break;
                case 'openparen':
                    currentIndex--;
                    property.value = parseArray();
                    break;
                default:
                    throw unexpectedToken(token);
            }
            assertNextToken('semicolon');
            properties.push(property);
            token = readNextToken();
        }
        return properties;
    };
    var parseNet = function () {
        var net = {
            type: 'net',
            properties: parseProperties()
        };
        return net;
    };
    var parseNode = function () {
        var node = {
            type: 'node',
            name: '',
            properties: []
        };
        var token = readNextToken();
        if (token.type !== 'identifier') {
            throw unexpectedToken(token);
        }
        node.name = token.value;
        node.properties = parseProperties();
        return node;
    };
    var parsePotential = function () {
        var potential = {
            type: 'potential',
            node: '',
            given: [],
            properties: []
        };
        assertNextToken('openparen');
        var token = readNextToken();
        if (token.type !== 'identifier') {
            throw unexpectedToken(token);
        }
        potential.node = token.value;
        token = readNextToken();
        if (token.type === 'pipe') {
            token = readNextToken();
            while (token.type !== 'closeparen') {
                if (token.type !== 'identifier') {
                    throw unexpectedToken(token);
                }
                potential.given.push(token.value);
                token = readNextToken();
            }
        }
        else if (token.type !== 'closeparen') {
            throw unexpectedToken(token);
        }
        potential.properties = parseProperties();
        return potential;
    };
    var parseAst = function () {
        var token = readNextToken();
        switch (token.type) {
            case 'net':
                return parseNet();
            case 'node':
                return parseNode();
            case 'potential':
                return parsePotential();
            default:
                throw unexpectedToken(token);
        }
    };
    var ast = {
        type: 'root',
        items: []
    };
    while (currentIndex < tokens.length) {
        ast.items.push(parseAst());
    }
    return ast;
};
